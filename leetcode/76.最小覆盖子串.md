# 76

2020-8-25 11:44:37

想想这个要干嘛。

n^2种可能性，要用O(n)的时间复杂度遍历出来。

想到了滑动区间，哈希表

就用滑动区间了！

2020-8-25 11:58:49
start

2020-8-25 12:21:53

```cpp
#include <iostream>
#include <unordered_map>
#include <algorithm>
#include <string>
using namespace std;
// @lc code=start
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> tmap;
        unordered_map<char, int> smap;
        for (int i = 0; i < t.size(); i++){
            tmap[t[i]]++;
        }
        int l = 0, r = 0;
        int ans = INT_MAX;
        int ans_l = 0;
        int ans_r = 0;
        while(l <= r && r < s.size()){
            while(r < s.size() && !comp(smap, tmap, t)){
                // cout << "!" << l << " " << r << endl;
                smap[s[r]]++;
                r++;
            }
            while(l <= r && comp(smap, tmap, t)){
                // cout << l << " " << r << endl;
                if (r-l < ans){
                    ans = r-l;
                    ans_l = l;
                    ans_r = r;
                }
                smap[s[l]]--;
                l++;
            }
        }
        return s.substr(ans_l, (ans_r-ans_l));
    }
    bool comp(unordered_map<char,int> & smap, unordered_map<char,int> & tmap, const string & t){
        for (int i = 0; i < t.size(); i++){
            // cout << t[i] << " " << smap[t[i]] << " " << tmap[t[i]] << endl;
            if (smap[t[i]] < tmap[t[i]]){
            // if (smap[t[i]] < 1){
                return false;
            }
        }
        return true;
    }
};
// @lc code=end
```

```
Time Limit Exceeded

267/268 cases passed (N/A)

Testcase
```

讲道理现在已经是O(n)了，但是还是TLE？？
一种可能的优化是将map换成数组，不过这不一定会变快，因为如果变成数组的话。


知道了，比较的遍历有性能问题，我改了一下：

2020-8-25 12:26:37

```cpp
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <string>
using namespace std;
// @lc code=start
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> tmap;
        unordered_map<char, int> smap;
        unordered_set<char> tchar;
        for (int i = 0; i < t.size(); i++){
            tmap[t[i]]++;
            tchar.insert(t[i]);
        }
        int l = 0, r = 0;
        int ans = INT_MAX;
        int ans_l = 0;
        int ans_r = 0;
        while(l <= r && r < s.size()){
            while(r < s.size() && !comp(smap, tmap, tchar)){
                // cout << "!" << l << " " << r << endl;
                smap[s[r]]++;
                r++;
            }
            while(l <= r && comp(smap, tmap, tchar)){
                // cout << l << " " << r << endl;
                if (r-l < ans){
                    ans = r-l;
                    ans_l = l;
                    ans_r = r;
                }
                smap[s[l]]--;
                l++;
            }
        }
        return s.substr(ans_l, (ans_r-ans_l));
    }
    bool comp(unordered_map<char,int> & smap, unordered_map<char,int> & tmap, unordered_set<char> & t){
        for (auto c : t){
            // cout << t[i] << " " << smap[t[i]] << " " << tmap[t[i]] << endl;
            if (smap[c] < tmap[c]){
            // if (smap[t[i]] < 1){
                return false;
            }
        }
        return true;
    }
};
// @lc code=end

```

```
Accepted

268/268 cases passed (516 ms)

Your runtime beats 5.05 % of cpp submissions

Your memory usage beats 21.16 % of cpp submissions (8.4 MB)
```

至少可以不看标答A出hard了。

开始看标答。

2020-8-25 12:28:11

https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/
https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/

优化空间：
1. 只处理t中出现的字符（可以减少那个map的空间占用）
2. TODO


大概以后可以再去优化优化，我觉得我现在写的优化可读性非常强。

优化：
1. https://leetcode-cn.com/problems/minimum-window-substring/solution/c-unordered_map-8ms-9847-by-karlzhang/

#TODO